from __future__ import annotations
import torch
from deepinv.optim.linear import least_squares
from dataclasses import dataclass
from deepinv.physics.forward import Physics, LinearPhysics
from deepinv.physics.functional.special import hankel1, bessel_j


class Scattering(Physics):
    r"""
    Inverse scattering physics model in 2 dimensions.

    For each of the :math:`i=1,\dots,T` transmitters, the 2D forward model is given by inhomogeneous Helmholtz equation (see e.g., :cite:t:`soubies2017efficient`):

    .. math::

        \nabla^2 u_i(\mathbf{r}) + k^2(\mathbf{r})  u_i(\mathbf{r}) = - (k^2(\mathbf{r}) - k^2_b)  v_i(\mathbf{r})  \quad \mathbf{r} \in \mathbb{R}^2

    where :math:`u_i` is the (unknown) scattered field, :math:`k_b` is the (known scalar) wavenumber of the incident wave in the background medium,
    :math:`k(\mathbf{r})` is the (unknown) spatially-varying wavenumber of the object to be recovered,
    and :math:`v_i` is the incident field generated by the ith transmitter in the absence of the object.
    The total field (scattered + incident) is measured at :math:`R` different receiver locations surrounding the object.


    Parametrizing the unknown spatially-varying wavenumber as :math:`k^2(\mathbf{r}) = k_b^2 (x(\mathbf{r})+1)`, where
    :math:`k_b` is the background wavenumber, and :math:`x = k^2/k_b^2 - 1` is the scattering potential of the object to be recovered,
    the problem can be reformulated in the **Lippmann-Schwinger** integral equation form:

    .. math::

        u_i &= g * \left( x \circ (u_i+v_i) \right) \\
        y_i &= G_s \left( x \circ (u_i+v_i) \right)

    where :math:`g(\mathbf{r}) = k_b^2 \frac{i}{4} H_0^1(k_b\|\mathbf{r}\|)` is Green's function in 2D (normalized by :math:`k_b^2`),
    :math:`y \in \mathbb{C}^{R}` are the measurements at the receivers for the ith transmitter,
    and :math:`G_s` denotes the convolution with Green's operator plus sampling at the :math:`R` different receiver locations.


    .. tip::

        This parametrization ensures that the scattering potential :math:`x` is dimensionless, and can be used for different physical
        modalities:
        In **microwave tomography** applications, the scattering potential is related to the object's relative permittivity :math:`\epsilon_r` as :math:`x(\mathbf{r}) = \epsilon_r(\mathbf{r}) - 1`.
        In **optical diffraction tomography**, the scattering potential is related to the refractive index :math:`n` as :math:`x(\mathbf{r}) = n^2(\mathbf{r}) - 1`.

        Moreover, the wavenumber can be also provided in a dimensionless form by normalizing it with respect to the box length :math:`L` as :math:`k_b = 2 \pi L / \lambda`,
        where :math:`\lambda` is the wavelength of the incident wave.

    All spatial quantities are discretized in a square grid of size `img_width x img_width` pixels, which
    is assumed to cover a square domain of size :math:`L \times L` in space, where :math:`L` is the box length.

    .. note::

        The forward operator uses a linear solver to compute the total field for each transmitter by solving the Lippmann-Schwinger equation.
        The default solver configuration can be modified by passing a custom :class:`deepinv.physics.Scattering.SolverConfig` object to the constructor.
        If the objects' contrast and/or the wavenumber is very large, the linear solver may not converge, leading to inaccurate results.
        Setting `verbose=True` in the constructor will print solver convergence information, which can help diagnose convergence issues.


    .. note::

        The forward operator uses the adjoint state method to compute gradients, e.g., :meth:`deepinv.physics.Scattering.A_jvp` and :meth:`deepinv.physics.Scattering.A_vjp` by default,
        which is more memory efficient than using autograd, especially for large-scale problems. The adjoint state method requires
        one additional solve of the Lippmann-Schwinger equation per gradient computation, and avoids storing the entire computational graph (done by standard autograd).
        This can be disabled by setting `adjoint_state=False` in the :class:`deepinv.physics.Scattering.SolverConfig` object passed to the constructor

    .. note::

        Green's function has a singularity at r=0. In practice, we can avoid this issue following :cite:t:`vico2016fast` which
        convolves Green's function with a sinc kernel to account for the bounded domain:

        .. math::

                g_L(\mathbf{r}) = g(\mathbf{r}) * \text{rect}\left(\frac{\|\mathbf{r}\|}{L}\right),


    :param int img_width: Number of pixels per image side (`H=W`). The minimum required number of pixels depends on the background wavenumber to avoid spatial aliasing.
        We require at least :math:`\text{image width} \geq 2 k_b L/(2 \pi)`, where :math:`k_b` is the background wavenumber and :math:`L` is the box length.
    :param torch.Tensor receivers: Tensor of shape `(2, R)` (shared receivers) or `(2, T, R)` (per-transmitter receivers) with receiver x/y positions (`torch.float` dtype).
    :param torch.Tensor transmitters: Tensor of shape `(2, T)` with transmitter x/y positions (`torch.float` dtype)
    :param float, torch.Tensor background_wavenumber: background wavenumber :math:`k_b`, which can be real (`float` or `torch.float`) or complex (`torch.complex`).
        It controls the frequency of the incident wave, and thus the maximum achievable resolution of the contrast image.
    :param deepinv.physics.scattering.Scattering.SolverConfig solver_config: Configuration for the Lippmann-Schwinger solver used to
        compute the total field (first equation in the forward model).
        If `None`, default configuration is used which uses the LSQR solver with a maximum of 500 iterations and tolerance 1e-5.
    :param float box_length: Physical side length of the square domain :math:`L`, which can be specified relative to the wavenumber.
    :param str wave_type: incident wave type. Options are `'circular_wave'` or `'plane_wave'`.
        The circular wave corresponds to a point source transmitter, while the plane wave corresponds to a far-field transmitter.
    :param str device: Torch device string, e.g. `'cpu'` or `'cuda'`.
    :param torch.dtype dtype: Torch `dtype` for tensors which must be of complex type (e.g. `torch.complex128`).
    :param bool verbose: Enable verbose/debug printing.
    """

    def __init__(
        self,
        img_width: int,
        receivers: torch.Tensor,
        transmitters: torch.Tensor,
        background_wavenumber: float = 10.0,
        solver_config: "Scattering.SolverConfig" = None,
        box_length: float = 1.0,
        wave_type: str = "circular_wave",
        device: torch.device | str = "cpu",
        dtype: torch.dtype = torch.complex128,
        verbose: bool = False,
    ):
        super(Scattering, self).__init__()
        if wave_type not in ["circular_wave", "plane_wave"]:
            raise ValueError(
                'Wave type not recognized, options are "circular_wave" or "plane_wave"'
            )

        # store a single scalar wavenumber (no wavenumber dimension)
        if not isinstance(background_wavenumber, torch.Tensor):
            wavenumber = torch.tensor(background_wavenumber, device=device, dtype=dtype)
        else:
            wavenumber = background_wavenumber.to(device, dtype=dtype).reshape(())

        self.register_buffer("wavenumber", wavenumber)

        if (2 * box_length * self.wavenumber.real / (2 * torch.pi)) > img_width:
            raise ValueError(
                "The number of img_width is not enough to sample the largest background wavenumber. Increase the number of img_width or decrease the wavenumber."
            )

        if solver_config is None:
            # default solver config
            solver_config = self.SolverConfig()

        self.solver = LippmannSchwingerSolver(
            img_width=img_width,
            box_length=box_length,
            wavenumber=self.wavenumber,
            device=device,
            dtype=dtype,
            config=solver_config,
        )
        self.verbose = verbose

        self.box_length = box_length
        self.pixel_area = (box_length / img_width) ** 2
        self.wave_type = wave_type
        self.img_width = img_width

        # incident field
        self.total_field = None

        self.update_parameters(
            receivers=receivers.to(device=device, dtype=dtype),
            transmitters=transmitters.to(device=device, dtype=dtype),
        )

    @dataclass
    class SolverConfig:
        r"""
        Configuration class for the Lippmann-Schwinger solver.

        Defines the parameters for the iterative solver used to solve the Lippmann-Schwinger equation.

        :param int min_iter: Minimum number of iterations. By default, 1.
        :param int max_iter: Maximum number of iterations. By default, 500.
        :param str solver: Linear solver to use (`'lsqr'`, `'BiCGStab'` or `'CG'`). By default, `'lsqr'`.
        :param float tol: Stopping criterion for the solver. By default, 1e-5.
        :param bool adjoint_state: If True, use adjoint state method for gradients, else use autograd. By default `True`.
        :param float green_imaginary_part: Small imaginary part to add to the wavenumber in the
            Green's function to improve solver convergence. By default, 0 (no modification).
        :param bool verbose: If True, print solver convergence information. By default, False.
        """

        min_iter: int = 1
        max_iter: int = 500
        solver: str = "lsqr"
        tol: float = 1e-5
        green_imaginary_part: float = 0.0
        adjoint_state: bool = True
        verbose: bool = False

    def get_img_grid(
        self, device: str | torch.device, dtype: torch.dtype
    ) -> tuple[torch.Tensor, ...]:
        image_domain = torch.linspace(
            -self.box_length / 2,
            self.box_length / 2,
            self.img_width,
            device=device,
            dtype=dtype,
        )
        y_domain, x_domain = torch.meshgrid(-image_domain, image_domain, indexing="ij")
        return x_domain.flatten(), y_domain.flatten()

    def normalize(self, x: torch.Tensor):
        """
        Normalize the operator to have unitary Jacobian spectral norm around the input contrast
        incident field and noise model by the operator norm.

        :param torch.Tensor x: Scattering potential of size `(B,1,H,W)`.
        """
        norm = self.compute_norm(x).sqrt()
        self.incident_field /= norm
        if hasattr(self.noise_model, "sigma"):
            self.noise_model.sigma /= norm

    def set_solver(self, solver_config: "Scattering.SolverConfig"):
        """
        Update the Lippmann-Schwinger solver configuration.

        :param deepinv.physics.Scattering.SolverConfig solver_config: New solver configuration.
        """
        self.solver = LippmannSchwingerSolver(
            img_width=self.img_width,
            box_length=self.box_length,
            wavenumber=self.wavenumber,
            device=self.wavenumber.device,
            dtype=self.wavenumber.dtype,
            config=solver_config,
        )

    def update_parameters(
        self,
        receivers: torch.Tensor = None,
        transmitters: torch.Tensor = None,
        **kwargs,
    ):
        """
        Update transmitter and receiver parameters and recompute dependent fields/operators.

        :param torch.Tensor receivers: New receiver positions of shape `(2, R)` or `(2, T, R)`.
        :param torch.Tensor transmitters: New transmitter positions of shape `(2, T)`, where `T` is the number of transmitters.
        """
        device = self.wavenumber.device
        dtype = self.wavenumber.dtype
        if transmitters is not None:
            self.register_buffer("transmitters", transmitters)
            self.transmitters = transmitters.to(dtype).to(device)
            # recompute the incident field
            incident_field = self.generate_incident_field(device=device, dtype=dtype)
            self.register_buffer("incident_field", incident_field)

        if receivers is not None:
            receivers = receivers.to(dtype).to(dtype)

            # Handle receivers: convert (2, R) to (2, T, R) if needed
            if receivers.ndim == 2:
                # Shared receivers across all transmitters: (2, R) -> (2, T, R)
                num_transmitters = self.transmitters.shape[1]
                receivers = (
                    receivers.unsqueeze(1).expand(2, num_transmitters, -1).contiguous()
                )

            self.register_buffer("receivers", receivers)
            # recompute the output linear operator
            x_domain, y_domain = self.get_img_grid(device=device, dtype=dtype)
            self.born_operator = BornOperator(
                total_field=self.incident_field,
                receivers=receivers,
                x_domain=x_domain,
                y_domain=y_domain,
                wavenumber=self.wavenumber,
                pixel_area=self.pixel_area,
                img_width=self.img_width,
                verbose=self.verbose,
            )

        super().update_parameters(**kwargs)

    def generate_incident_field(
        self, device: torch.device, dtype: torch.dtype
    ) -> torch.Tensor:
        r"""
        Generate incident fields on the image grid and at receiver positions.

        Plane waves are computed as:

        .. math::

            v_i(\mathbf{r}) = \exp\left( \mathrm{i} \mathbf{k}_i^{\top} \mathbf{r} \right)

        where :math:`\mathbf{k}_i` is the wavevector for the ith transmitter.

        Circular waves are computed using Green's function as:

        .. math::

            v_i(\mathbf{r}) = g(\|\mathbf{r} - \mathbf{r}_i\|)

        where :math:`\mathbf{r}_i` is the position of the ith transmitter.

        :returns: (:class:`torch.Tensor`) Incident field tensor of shape `(1,T,H,W)` where `T` is the number of transmitters.
        """
        x_domain, y_domain = self.get_img_grid(device=device, dtype=dtype)
        x_transmitters, y_transmitters = self.transmitters.to(
            dtype=dtype, device=device
        )

        if self.wave_type == "plane_wave":
            # to angles
            transmitter_angles = torch.atan2(y_transmitters.real, x_transmitters.real)
            k = self.wavenumber
            wave_number_x = k * torch.cos(transmitter_angles)  # (T,)
            wave_number_y = k * torch.sin(transmitter_angles)  # (T,)
            aux = wave_number_x.unsqueeze(1) * x_domain.unsqueeze(
                0
            ) + wave_number_y.unsqueeze(1) * y_domain.unsqueeze(
                0
            )  # (T, H*W)
            incident_field = torch.exp(1j * aux)
            incident_field = incident_field.reshape(
                1, incident_field.size(0), self.img_width, self.img_width
            )  # (1, T, H, W)
        else:  # circular_wave
            transmitter_x, circle_x = torch.meshgrid(
                x_transmitters, x_domain, indexing="ij"
            )
            transmitter_y, circle_y = torch.meshgrid(
                y_transmitters, y_domain, indexing="ij"
            )
            dist_transmitter_circles = torch.sqrt(
                (circle_x - transmitter_x).abs() ** 2
                + (circle_y - transmitter_y).abs() ** 2
            )

            # multiply distances by scalar wavenumber
            dist_transmitter_circles = (
                dist_transmitter_circles * self.wavenumber
            )  # (T, H*W)
            incident_field = green_function(dist_transmitter_circles)
            incident_field = incident_field.reshape(
                1, incident_field.size(0), self.img_width, self.img_width
            )  # (1, T, H, W)

        return incident_field

    def A_jvp(self, x: torch.Tensor, u: torch.Tensor, **kwargs):
        r"""
        Jacobian-vector product for the forward operator.

        :param torch.Tensor x: Scattering potential `(B,1,H,W)`.
        :param torch.Tensor u: Vector to multiply with the Jacobian `(B,1,H,W)`.
        """
        return torch.autograd.functional.jvp(self.A, x, v=u)[1]

    def A_vjp(self, x: torch.Tensor, v: torch.Tensor, **kwargs):
        """
        Vector-Jacobian product for the forward operator.

        :param torch.Tensor x: Scattering potential of shape `(B,1,H,W)`.
        :param torch.Tensor v: Vector to multiply with the Jacobian, a tensor of shape `(B,T,R)`.
        :param torch.dtype dtype: torch.dtype used for internal computations and returned result
        """
        with torch.enable_grad():
            # we need a fresh forward pass to build the graph for autograd
            x.requires_grad_(True)
            y = self.A(x)
            return torch.autograd.grad(y, x, grad_outputs=v, retain_graph=False)[0]

    def compute_total_field(self, x: torch.Tensor, **kwargs) -> torch.Tensor:
        """
        Solve for the total field given scattering potential `x` using the provided solver.

        :param torch.Tensor x: Scattering potential tensor of shape `(B,1,H,W)`.
        :returns: (:class:`torch.Tensor`) Total field tensor of shape `(B,T,H,W)`.
        """
        # This solves the following linear problem: (I - G_d*diag(x))u = v

        k02 = self.wavenumber**2
        k2 = k02 * (x + 1)
        s = (k2 - k02) * self.incident_field
        return self.solver(k2, s) + self.incident_field

    def set_verbose(self, verbose: bool):
        """
        Toggle verbosity.

        :param bool verbose: Enable verbose/debug printing.
        """
        self.verbose = verbose
        self.born_operator.verbose = verbose
        self.solver.set_verbose(verbose)

    def compute_field_out(
        self, x: torch.Tensor, total_field: torch.Tensor
    ) -> torch.Tensor:
        """
        Compute sensor outputs :math:`y = G_s * \text{diag}(x) u`.

        :param torch.Tensor x: Scattering potential `(B,1,H,W)`.
        :param torch.Tensor total_field: Total field u `(B,T,H,W)`.
        """
        # This computes y = G_s*diag(x)*Et
        self.born_operator.register_buffer("total_field", total_field)
        return self.born_operator.A(x)

    def A(
        self,
        x: torch.Tensor,
        receivers: torch.Tensor = None,
        transmitters: torch.Tensor = None,
        **kwargs,
    ) -> torch.Tensor:
        """
        Forward operator wrapper: updates parameters, solves for total field and returns measurements.

        :param torch.Tensor x: Scattering potential `(B,1,H,W)`.
        :param torch.Tensor receivers: Optional new receiver positions of shape `(2, R)` or `(2, T, R)`.
        :param torch.Tensor transmitters: Optional new transmitter positions of shape `(2, T)`, where T is the number of transmitters.
        :returns: (:class:`torch.Tensor`) Measurements tensor of shape `(B,T,R)`.
        """
        self.update_parameters(receivers, transmitters, **kwargs)
        total_field = self.compute_total_field(x)
        out = self.compute_field_out(x, total_field)
        return out

    def A_dagger(
        self,
        y: torch.Tensor,
        linear: bool = False,
        x_init: torch.Tensor = None,
        max_iter: int = 2,
        use_init: bool = True,
        rel_tol: float = 1e-3,
        **kwargs,
    ):
        """
        Pseudo-inverse for the scattering operator.

        If `linear=True`, uses the Born approximation (single iteration).

        If `linear=False`, alternates between updating the total field estimate with a fixed scattering potential,
        and updating the scattering potential estimate with a fixed total field, for a maximum of `max_iter` iterations.

        :param torch.Tensor y: Measurements tensor (B,T,R).
        :param bool linear: If True, use Born approximation (single iteration).
        :param torch.Tensor x_init: Initial guess for the reconstruction (B,1,H,W).
        :param int max_iter: Maximum number of alternating optimization iterations.
        :param bool use_init: If True, use previous total field estimate to initialize the next iteration.
        :param float rel_tol: Relative tolerance for convergence.
        """
        if linear:
            max_iter = 1

        if x_init is not None:
            x = x_init
        else:
            x = (
                torch.ones(
                    (y.shape[0], 1, self.img_width, self.img_width),
                    dtype=y.dtype,
                    device=y.device,
                )
                * 0.05
            )

        flag = True
        if use_init:
            total_field = self.incident_field
        else:
            total_field = None

        for i in range(max_iter):
            prev_x = x.clone()

            if linear:
                total_field = self.incident_field
            else:
                total_field = self.compute_total_field(
                    x, init=total_field if use_init else None
                )

            self.born_operator.total_field = total_field
            x = self.born_operator.A_dagger(y, init=x if use_init else None)
            rel_err = (x - prev_x).abs().pow(2).mean() / prev_x.abs().pow(2).mean()
            if rel_err < rel_tol:
                flag = False
                if self.verbose:
                    print(
                        "Alternated optimization pseudo inverse converged at iteration",
                        i,
                    )
                break

        if flag and not linear and max_iter != 2:
            if self.verbose:
                print("Alternated optimization pseudo inverse did not converge")

        return x


class BornOperator(LinearPhysics):
    r"""
    Linear operator implementing the Born approximation for the scattering problem.

    It computes the measurements at the receivers given a total field and a scattering potential, according to the following operation:

    .. math::

        y = G_s \left( x \circ u \right)

    where :x: is the scattering potential, :math:`u` is the (here known) total field (scattered + incident), and :math:`G_s` is the Green's operator plus sampling at the receiver locations.

    :param torch.Tensor total_field: Total field tensor `(1,T,H,W)` or `(B,T,H,W)`.
    :param torch.Tensor receivers: Receiver positions of shape `(2, T, R)`.
    :param torch.Tensor x_domain: x coordinates of image grid points `(H*W,)`.
    :param torch.Tensor y_domain: y coordinates of image grid points `(H*W,)`.
    :param float, torch.Tensor wavenumber: Scalar wavenumber.
    :param float pixel_area: Area of each pixel in the discretized grid.
    :param int img_width: Number of pixels per image side (H=W).
    :param bool verbose: Enable verbose/debug printing.
    """

    def __init__(
        self,
        total_field: torch.Tensor,
        receivers: torch.Tensor,
        x_domain: torch.Tensor,
        y_domain: torch.Tensor,
        wavenumber: float | torch.Tensor,
        pixel_area: float,
        img_width: int,
        verbose: bool = False,
    ):
        super().__init__()
        self.register_buffer("total_field", total_field)
        green_operator = self.compute_operator(
            receivers,
            x_domain,
            y_domain,
            wavenumber,
            pixel_area,
            img_width,
            dtype=total_field.dtype,
            device=total_field.device,
        )
        self.register_buffer("green_operator", green_operator)
        self.verbose = verbose

    def A(self, x: torch.Tensor, **kwargs) -> torch.Tensor:
        """
        Linear forward operation

        This operator computes the following operation:

        :math:`y = G_s (u \circ x)`

        where :math:`u` is the total field stored in the object.

        :param torch.Tensor x: Scattering potential `(B,1,H,W)`.
        :returns: (:class:`torch.Tensor`) Measurements `(B,T,R)`.
        """
        # x: (B,1,H,W), total_field: (1,T,H,W) -> aux (B,T,H,W)
        aux = x * self.total_field
        # green_operator: (T,R,H,W), aux: (B,T,H,W) -> y: (B,T,R)
        y = torch.einsum("bthw, trhw->btr", aux, self.green_operator)
        return y  # (B,T,R)

    def A_adjoint(self, y: torch.Tensor, **kwargs) -> torch.Tensor:
        """
        Adjoint operation mapping measurements back to image domain.

        :param torch.Tensor y: Measurements `(B,T,R)`.
        :returns: (:class:`torch.Tensor`) Scattering potential `(B,1,H,W)`.
        """
        # y: (B, T, R), green_operator: (T, R, H, W) -> aux: (B, T, H, W)
        aux = torch.einsum("btr, trhw->bthw", y, self.green_operator.conj())
        x = self.total_field.conj() * aux  # (B, T, H, W)
        x = x.sum(1, keepdim=True)  # (B,1,H,W)
        return x

    def A_dagger(
        self,
        y: torch.Tensor,
        init: torch.Tensor = None,
        solver: str = "lsqr",
        gamma: float = 1e3,
        **kwargs,
    ) -> torch.Tensor:
        """
        Solve least-squares for x given y using the operator A and its adjoint.

        :param torch.Tensor y: Measurements `(B,T,R)`.
        :param None, torch.Tensor init: Initial guess for the solver `(B,1,H,W)`.
        :param str solver: Solver to use (`'lsqr'`, `'BiCGStab'` or `'CG'`), see :func:`deepinv.optim.linear.least_squares`.
        :param float gamma: Regularization parameter for the least-squares solver.
        :returns: (:class:`torch.Tensor`) Scattering potential `(B,1,H,W)`.
        """
        x = least_squares(
            A=self.A,
            AT=self.A_adjoint,
            gamma=gamma,
            y=y,
            solver=solver,
            dim=[0],
            init=init,
            max_iter=100,
            tol=5e-3,
            verbose=self.verbose,
        )
        return x

    @staticmethod
    def compute_operator(
        receivers: torch.Tensor,
        x_domain: torch.Tensor,
        y_domain: torch.Tensor,
        wavenumber: torch.Tensor | float,
        pixel_area: float,
        img_width: int,
        dtype: torch.dtype,
        device: torch.device | str,
    ) -> torch.Tensor:
        """
        Compute Green's function sampled at receiver positions and grid points.

        Returns a tensor of shape `(T, R, H, W)` where receivers can vary per transmitter.

        :param torch.Tensor receivers: Receiver positions of shape `(2, T, R)`.
        :param torch.Tensor x_domain: x coordinates of image grid points `(H*W,)`.
        :param torch.Tensor y_domain: y coordinates of image grid points `(H*W,)`.
        :param float, torch.Tensor wavenumber: Scalar wavenumber.
        :param float pixel_area: Area of each pixel in the discretized grid.
        :param int img_width: Number of img_width per image side `(H=W)`.
        :param torch.dtype dtype: torch.dtype used for internal computations and returned result
        :param str, torch.device device: `torch.device` used for internal computations and returned result
        :returns: (:class:`torch.Tensor`) Green's function operator of shape `(T, R, H, W)`.
        """

        # receivers shape: (2, T, R)
        num_transmitters = receivers.shape[1]
        num_receivers = receivers.shape[2]

        # Initialize output: (T, R, H*W)
        receivers_operator = torch.zeros(
            num_transmitters,
            num_receivers,
            x_domain.shape[0],
            dtype=dtype,
            device=device,
        )

        for t in range(num_transmitters):
            # Get receivers for this transmitter: (2, R)
            receivers_t = receivers[:, t, :]  # (2, R)

            x_circles, x_receivers = torch.meshgrid(
                x_domain, receivers_t[0, :], indexing="ij"
            )
            y_circles, y_receivers = torch.meshgrid(
                y_domain, receivers_t[1, :], indexing="ij"
            )
            dist_receivers_circles = torch.sqrt(
                (x_circles - x_receivers).abs() ** 2
                + (y_circles - y_receivers).abs() ** 2
            )
            dist_receivers_circles = dist_receivers_circles.T  # (R, H*W)

            # scalar wavenumber
            k = wavenumber
            receivers_operator[t, :, :] = green_function(
                dist_receivers_circles * k
            )  # (R, H*W)

        receivers_operator = receivers_operator.reshape(
            num_transmitters, num_receivers, img_width, img_width
        )  # (T, R, H, W)

        # use normalized Green's function (postmultiplied by k_b^2)
        receivers_operator *= wavenumber**2
        # account for pixel area in the discretized integral
        receivers_operator *= pixel_area

        # shape (T, R, H, W)
        return receivers_operator


def circular_sensors(
    number: int,
    radius: float,
    max_angle: int = 360,
    offset_angle: int = 0,
    device: torch.device | str = "cpu",
):
    """
    Generate equispaced sensors on a circle.

    :param int number: Number of sensors.
    :param float radius: Radius of the circle.
    :param float max_angle: Maximum angle in degrees covered by sensors.
    :param float offset_angle: Offset angle in degrees.
    :param str device: Torch device for tensors.
    :return: Tuple of tensors:
         - `transmitters`: Tensor of shape `(2, number)` with (x,y) positions.
         - `receivers`: Tensor of shape `(2, number, number-1)` with (x,y) positions.

    """
    angles = (
        torch.linspace(0, max_angle / 360 * 2 * torch.pi, number + 1, device=device)[
            :-1
        ]
        + offset_angle / 360 * 2 * torch.pi
    )
    receiver_radii = radius
    x_pos = receiver_radii * torch.cos(angles)
    y_pos = receiver_radii * torch.sin(angles)
    transmitters = torch.stack([x_pos, y_pos])  # 2, number
    # receivers = torch.zeros((2, number, number - 1), device=device)

    mask = ~torch.eye(number, dtype=torch.bool, device=device)
    all_indices = torch.arange(number, device=device).expand(number, number)
    valid_indices = all_indices[mask].view(number, number - 1)
    receivers = transmitters[:, valid_indices]
    return transmitters, receivers


def forward_lippmann_schwinger(
    m: torch.Tensor,
    source: torch.Tensor,
    g_fourier: torch.Tensor,
    init: torch.Tensor = None,
    config: "Scattering.SolverConfig" = None,
) -> tuple[torch.Tensor, torch.Tensor]:
    r"""
    Computes the scattered field by solving the Lippmann-Schwinger equation using an iterative solver.

    :param torch.Tensor m: Scattering potential `(B,1,H,W)`.
    :param torch.Tensor source: Source term `(B,T,H,W)`.
    :param torch.Tensor g_fourier: Green's function in Fourier space `(1,H,W)`.
    :param dict solver_config: Dictionary of solver parameters for the least-squares solver.
    :param None, torch.Tensor init: Initial guess for the scattered field `(B,T,H,W)`.
    :returns: (:class:`torch.Tensor`, :class:`torch.Tensor`)
        - Scattered field `(B,T,H,W)`.
        - Incident field `(B,T,H,W)`.
    """
    # Define the forward operator A(u) = u - G * (m * u)
    A = lambda u: u - apply_filter(m * u, g_fourier)

    # Define its adjoint AT(u) = u - m.conj() * G.conj()(u)
    AT = lambda u: u - m.conj() * apply_filter(u, g_fourier.conj())

    # The right-hand side is the incident field u_i = G * source
    b_incident_field = apply_filter(source, g_fourier)

    scattered_field = least_squares(
        A=A,
        AT=AT,
        y=b_incident_field,
        init=init,
        **vars(config) if config is not None else {},
    )
    return scattered_field, b_incident_field


class LippmannSchwingerSolver(torch.nn.Module):
    r"""
    Lippmann-Schwinger equation solver using iterative methods.

    :param int img_width: Number of img_width per image side (`H=W`).
    :param float box_length: Physical side length of the square domain.
    :param torch.Tensor wavenumber: Wavenumber (real or complex).
    :param SolverConfig config: Solver configuration parameters.
    :param bool verbose: Enable verbose/debug printing.
    :param str device: Torch device string, e.g. 'cpu' or 'cuda'.
    :param torch.dtype dtype: Torch `dtype` for tensors (e.g. `torch.complex128`).
    """

    def __init__(
        self,
        img_width: int,
        box_length: float,
        wavenumber: torch.Tensor,
        config: "Scattering.SolverConfig" = None,
        device: torch.device | str = "cpu",
        dtype: torch.dtype = torch.complex128,
    ):
        super().__init__()

        # Pre-compute Green's function in Fourier space and move to device
        _, g_fourier = green_fourier(
            img_width,
            box_length,
            (wavenumber.pow(2) + 1j * config.green_imaginary_part).sqrt(),
        )
        self.register_buffer("g_fourier", g_fourier)
        self.register_buffer("k02", wavenumber.pow(2).to(device))
        self.register_buffer("g_fourier", self.g_fourier.to(device).to(dtype))
        self.adjoint_state = config.adjoint_state

        # Store solver parameters in a dictionary for easy passing
        self.solver_config = config

    def set_verbose(self, verbose: bool):
        """
        Toggle verbosity.

        :param bool verbose: Enable verbose/debug printing.
        """
        self.solver_config.verbose = verbose

    def forward(
        self,
        k2: torch.Tensor,
        source: torch.Tensor,
        init: torch.Tensor = None,
        **kwargs,
    ) -> torch.Tensor:
        """
        Calls the custom autograd function to solve the equation.
        PyTorch will automatically use the defined `.backward()` method during backpropagation.

        :param torch.Tensor k2: Squared space-varying wavenumber tensor `(B,1,H,W)`.
        :param torch.Tensor source: Source term tensor `(B,T,H,W)`.
        :param None, torch.Tensor init: Initial guess for the scattered field `(B,T,H,W)`.
        :returns: (:class:`torch.Tensor`) Scattered field tensor `(B,T,H,W)`.
        """
        # sizes total_field = (B, T, F, H, W), green_function = (1, F, H, W), y = (B, R, F), x = (B, 1, H, W), incident_field = (T, R, H, W)
        # Pack non-tensor parameters and call the custom function
        if self.adjoint_state:
            # Use the Lippmann-Schwinger function with adjoint state
            return LippmannSchwingerAdjointState.apply(
                k2, source, init, self.g_fourier, self.k02, self.solver_config
            )
        else:
            scattered_field, _ = forward_lippmann_schwinger(
                k2 - self.k02,
                source,
                self.g_fourier,
                init=init,
                config=self.solver_config,
            )
            return scattered_field


class LippmannSchwingerAdjointState(torch.autograd.Function):
    """
    Implements the Lippmann-Schwinger forward solver and its analytical
    adjoint-state method for the backward pass.
    """

    @staticmethod
    def forward(ctx, k2, source, init, g_fourier, k02, config):
        """
        Solves for the scattered field using an iterative solver.
        """

        m = k2 - k02  # Scattering potential
        scattered_field, b_incident_field = forward_lippmann_schwinger(
            m, source, g_fourier, config=config, init=init
        )

        # Save necessary tensors for the backward pass
        ctx.config = config
        ctx.save_for_backward(m, scattered_field, b_incident_field, g_fourier)
        return scattered_field

    @staticmethod
    def backward(ctx, grad_scattered_field):
        """
        Computes the gradient of the loss with respect to k2 and source
        using the pre-derived closed-form Frechet derivative.
        """
        # Unpack saved tensors and parameters
        config = ctx.config
        m, scattered_field, b_incident_field, g_fourier = ctx.saved_tensors

        # Initialize gradients to None
        grad_k2 = grad_source = grad_init = None

        # Only proceed if gradients for k2 or source are required
        if not (ctx.needs_input_grad[0] or ctx.needs_input_grad[1]):
            return None, None, None, None, None, None

        ### Adjoint-State Calculation

        # Define the forward operator A(u) = u - G * (m * u)
        A = lambda u: u - apply_filter(m * u, g_fourier)

        # Define its adjoint AT(u) = u - m.conj() * G.conj()(u)
        AT = lambda u: u - m.conj() * apply_filter(u, g_fourier.conj())

        # 1. Adjoint Solve: Solve AT(v) = grad_output for the adjoint field 'v'
        init_adjoint = scattered_field.conj().clone()

        v = least_squares(
            A=AT,
            AT=A,
            y=grad_scattered_field,
            init=init_adjoint,
            **vars(config) if config is not None else {},
        )

        g_adj_v = apply_filter(v, g_fourier.conj())

        # 2. Gradient Calculation for k2
        if ctx.needs_input_grad[0]:
            grad_k2 = scattered_field.conj() * g_adj_v

        # 3. Gradient Calculation for source
        if ctx.needs_input_grad[1]:
            # grad_source = G_adj(v)
            grad_source = g_adj_v

        # Return gradients in the same order as inputs to forward()
        return grad_k2, grad_source, grad_init, None, None, None


def green_function(r, remove_nans=False):
    """
    Green's function in 2D based on Hankel function H_0^{(1)}.

    :param torch.Tensor r: Radial argument(s) (can be tensor).
    :param bool remove_nans: If True replace NaNs (singularity) with max abs value.
    :param torch.dtype dtype: torch.dtype used for the returned tensor (matches r.dtype)
    :return: Complex tensor with Green's function values.
    """
    out = 1j / 4 * hankel1(0, r.abs())
    if remove_nans:
        out[torch.isnan(out)] = out.abs().max()  # singularity at 0
    return out


def green_fourier(
    img_width: int, box_length: float, wavenumber: torch.Tensor
) -> tuple[torch.Tensor, torch.Tensor]:
    r"""
    Green function discretization for :cite:t:`vico2016fast` in 2D.

    :param int img_width: image width H=W
    :param float box_length: physical box length
    :param torch.Tensor or scalar wavenumber: scalar wavenumber expected
    :return: Tuple of:
         - `filter`: (:class:`torch.Tensor`) Spatial-domain filter of shape `(1, H*factor, W*factor)`.
         - `filterf`: (:class:`torch.Tensor`) Fourier-domain filter of shape `(1, H*factor, W*factor)`.
    """
    n = 4 * img_width
    aux = torch.fft.fftfreq(n, d=4 * box_length / n).to(wavenumber.device)

    fx_domain = aux.unsqueeze(1)
    fy_domain = aux.unsqueeze(0)
    s = torch.sqrt(fx_domain**2 + fy_domain**2) * 2 * torch.pi  # (n, n)
    k = wavenumber  # scalar

    filterf = 1.0 + 0j

    # use Vico's paper correction
    L = 1.5 * box_length  # for d=2
    constant = 1j * torch.pi * L / 2
    filterf = filterf + constant * s * bessel_j(1, L * s) * hankel1(0, L * k)
    filterf = filterf - constant * k * bessel_j(0, L * s) * hankel1(1, L * k)

    filterf = filterf / (s**2 - k**2)
    filterf = filterf / 2

    # to (1, H, W)
    filter = torch.fft.ifft2(filterf, norm="ortho")
    filter = torch.fft.fftshift(filter)[
        ..., img_width : 3 * img_width, img_width : 3 * img_width
    ]
    filter = torch.fft.ifftshift(filter)
    filter = filter.unsqueeze(0)

    filterf = torch.fft.fft2(filter, norm="ortho")

    return filter, filterf


def apply_filter(field, filterf, factor=2, padding_mode="constant"):
    """
    Apply a Fourier-domain filter to a field with optional factor padding.

    :param torch.Tensor field: Input field with shape (..., H, W).
    :param torch.Tensor filterf: Fourier filter of shape (1, H*factor, W*factor) or broadcastable.
    :param int factor: Oversampling / padding factor.
    :param str padding_mode: Padding mode used before FFT.
    :param torch.dtype dtype: torch.dtype used for returned field (matches input)
    :return: Filtered field cropped to original size.
    """
    H, W = field.shape[-2], field.shape[-1]
    H2 = H * (factor - 1) // 2
    W2 = W * (factor - 1) // 2
    # pad input
    field = torch.nn.functional.pad(field, (W2, W2, H2, H2), mode=padding_mode, value=0)

    # filter in fourier space
    xf = torch.fft.fft2(field, norm="ortho")
    yf = xf * filterf.unsqueeze(0)
    y = torch.fft.ifft2(yf, norm="ortho")
    # crop output
    y = y[..., H2 : H2 + H, W2 : W2 + W]
    return y


def mie_theory(
    wavenumber: torch.Tensor | float,
    cylinder_radius: float,
    cylinder_contrast: float,
    img_width: int,
    angles: torch.Tensor,
    wave_type: str = "plane_wave",
    box_length: float = 1.0,
    dtype: torch.dtype = torch.complex128,
    device: str | torch.device = "cpu",
    n_coeffs: int = 70,
    transmitter_radius: float = 1.0,
) -> tuple[torch.Tensor, torch.Tensor]:
    r"""
    Compute the total field using the closed form formula from Mie theory for a single cylinder.

    Can be used for validation of the Lippmann-Schwinger solver.

    :param torch.Tensor or scalar wavenumber: Wavenumber.
    :param float cylinder_radius: Radius of the cylinder.
    :param float cylinder_contrast: Contrast of the cylinder (relative permittivity - 1).
    :param int img_width: Number of img_width per image side.
    :param torch.Tensor angles: Incident wave angles (radians) of shape (P,).
    :param str wave_type: Type of incident wave ('plane_wave' or 'circular_wave').
    :param float box_length: Physical side length of the square domain.
    :param torch.dtype dtype: torch.dtype used for intermediate and returned tensors.
    :param str device: Torch device string, e.g. 'cpu' or 'cuda'.
    :param int n_coeffs: Number of Fourier coefficients to use in the series expansion.
    :param float transmitter_radius: Radius of the circular wave transmitter (only for 'circular_wave' type).
    :return: total_field, incident_field tensors of shape (1, P, img_width, img_width).
    """
    if not isinstance(wavenumber, torch.Tensor):
        wavenumber = torch.tensor(wavenumber, dtype=dtype, device=device)
    else:
        wavenumber = wavenumber.to(dtype=dtype, device=device)

    grid = torch.linspace(-box_length / 2, box_length / 2, img_width, device=device)
    yy, xx = torch.meshgrid(-grid, grid, indexing="ij")
    r = torch.sqrt(xx**2 + yy**2)
    theta = torch.atan2(yy, xx)

    incident_field = torch.zeros(
        1, angles.shape[0], img_width, img_width, device=device, dtype=dtype
    )
    total_field = torch.zeros_like(incident_field)
    jv_prime = lambda n, x: 0.5 * (bessel_j(n - 1, x) - bessel_j(n + 1, x))
    hankel1_prime = lambda n, x: 0.5 * (hankel1(n - 1, x) - hankel1(n + 1, x))

    list_n = [0]
    for i in range(1, n_coeffs):
        list_n.append(i)
        list_n.append(-i)

    extra_contrast = torch.sqrt(torch.tensor(1 + cylinder_contrast, dtype=dtype))
    w = wavenumber.abs()
    ind = r < cylinder_radius
    for p in range(angles.shape[0]):
        for n in list_n:
            # calculate incident and total fields
            jvn = bessel_j(n, w * extra_contrast * cylinder_radius)
            jvn_prime = jv_prime(n, w * extra_contrast * cylinder_radius)
            jv0n = bessel_j(n, w * cylinder_radius)
            jv0n_prime = jv_prime(n, w * cylinder_radius)
            hn = hankel1(n, w * cylinder_radius)
            hn_prime = hankel1_prime(n, w * cylinder_radius)

            if wave_type == "plane_wave":
                incident_coeff = 1j**n
            elif wave_type == "circular_wave":
                incident_coeff = 1j / 4 * hankel1(n, w * transmitter_radius)
                if torch.isnan(incident_coeff):
                    print("incident_coeff is nan", n)
                    incident_coeff = 0.0
            else:
                raise ValueError(
                    f"Wave type {wave_type} not supported, please choose 'plane_wave' or 'circular_wave'"
                )

            incident_coeff *= torch.exp(-1j * n * angles[p])

            # incident field
            term = incident_coeff * bessel_j(n, w * r) * torch.exp(1j * n * theta)
            if torch.isnan(term).any():
                print("incident field is nan", n)
                break
            incident_field[0, p, ...] += term

            # total field for r < cylinder_radius
            Tn = 2j / (torch.pi * w * cylinder_radius)
            Tn /= jvn * hn_prime - extra_contrast * (jvn_prime * hn)
            coeff = Tn * incident_coeff

            term = (
                coeff
                * bessel_j(n, w * extra_contrast * r[ind])
                * torch.exp(1j * n * theta[ind])
            )
            if torch.isnan(term).any():
                print("total field is nan", n)
                break
            total_field[0, p, ind] += term

            # total field for r > cylinder_radius
            # add incident field
            coeff = incident_coeff
            total_field[0, p, ~ind] += (
                coeff * bessel_j(n, w * r[~ind]) * torch.exp(1j * n * (theta[~ind]))
            )

            # add scattered field
            num = extra_contrast * jv0n * jvn_prime - jvn * jv0n_prime
            den = jvn * hn_prime - extra_contrast * (jvn_prime * hn)
            Rn = num / den
            coeff = Rn * incident_coeff

            term = coeff * hankel1(n, w * r[~ind]) * torch.exp(1j * n * theta[~ind])
            if torch.isnan(term).any():
                print("total field is nan", n)
                break

            total_field[0, p, ~ind] += term

    return total_field, incident_field
